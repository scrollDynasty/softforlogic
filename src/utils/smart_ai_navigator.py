import asyncio
import json
import base64
import time
from typing import Dict, List, Optional, Any, Tuple
from playwright.async_api import Page, ElementHandle
import google.generativeai as genai
from ..utils.logger import logger

class SmartAINavigator:
    """
    üß† –£–º–Ω—ã–π AI-–Ω–∞–≤–∏–≥–∞—Ç–æ—Ä –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å —Å–∞–π—Ç–æ–º
    
    –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:
    - –ê–Ω–∞–ª–∏–∑ —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    - –ü—Ä–∏–Ω—è—Ç–∏–µ —Ä–µ—à–µ–Ω–∏–π –æ —Å–ª–µ–¥—É—é—â–∏—Ö –¥–µ–π—Å—Ç–≤–∏—è—Ö
    - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö
    - –ê–¥–∞–ø—Ç–∞—Ü–∏—è –∫ –∏–∑–º–µ–Ω–µ–Ω–∏—è–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    - –û–±—É—á–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ–ø—ã—Ç–∞
    """
    
    def __init__(self, api_key: str):
        try:
            self.api_key = api_key
            logger.info(f"üîë –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Gemini —Å API –∫–ª—é—á–æ–º: {api_key[:10] if api_key else 'None'}...")
            genai.configure(api_key=api_key)
            self.model = genai.GenerativeModel('gemini-2.5-flash')  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª–µ–µ –±—ã—Å—Ç—Ä—É—é –º–æ–¥–µ–ª—å
            logger.info("‚úÖ Gemini –º–æ–¥–µ–ª—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ —É—Å–ø–µ—à–Ω–æ")
            
            # –ò—Å—Ç–æ—Ä–∏—è –¥–µ–π—Å—Ç–≤–∏–π –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
            self.action_history = []
            self.success_patterns = {}
            self.failure_patterns = {}
            
            logger.info("üß† Smart AI Navigator –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Gemini: {e}")
            raise
    
    async def analyze_and_navigate(self, page: Page, goal: str, context: Dict = None) -> Dict[str, Any]:
        """
        –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥: –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Å–∏—Ç—É–∞—Ü–∏—é –∏ –≤—ã–ø–æ–ª–Ω—è–µ—Ç –Ω–∞–≤–∏–≥–∞—Ü–∏—é –∫ —Ü–µ–ª–∏
        
        Args:
            page: Playwright —Å—Ç—Ä–∞–Ω–∏—Ü–∞
            goal: –¶–µ–ª—å –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "navigate_to_search_page")
            context: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç (—É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ, –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –æ—à–∏–±–∫–∏ –∏ —Ç.–¥.)
        
        Returns:
            Dict —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –∞–Ω–∞–ª–∏–∑–∞ –∏ –¥–µ–π—Å—Ç–≤–∏–π
        """
        start_time = time.time()
        
        try:
            logger.info(f"üß† AI –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Å–∏—Ç—É–∞—Ü–∏—é –¥–ª—è —Ü–µ–ª–∏: {goal}")
            
            # 1. –ê–Ω–∞–ª–∏–∑ —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
            page_analysis = await self._analyze_current_state(page)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –æ—à–∏–±–∫–∞ –≤ –∞–Ω–∞–ª–∏–∑–µ
            if 'error' in page_analysis:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã: {page_analysis['error']}")
                return {
                    'success': False,
                    'error': f"Page analysis failed: {page_analysis['error']}",
                    'execution_time': time.time() - start_time
                }
            
            # 2. –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –¥–µ–π—Å—Ç–≤–∏–π
            strategy = await self._determine_strategy(page_analysis, goal, context)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
            if not strategy.get('actions'):
                logger.error("‚ùå AI –Ω–µ —Å–º–æ–≥ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –¥–µ–π—Å—Ç–≤–∏–π")
                return {
                    'success': False,
                    'error': 'No strategy determined by AI',
                    'execution_time': time.time() - start_time
                }
            
            # 3. –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏–π
            result = await self._execute_strategy(page, strategy, goal)
            
            # 4. –û–±—É—á–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            await self._learn_from_result(page_analysis, strategy, result, goal)
            
            execution_time = time.time() - start_time
            logger.info(f"‚è±Ô∏è AI –Ω–∞–≤–∏–≥–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∑–∞ {execution_time:.1f}—Å")
            
            return {
                'success': result.get('success', False),
                'actions_taken': result.get('actions', []),
                'analysis': page_analysis,
                'strategy': strategy,
                'execution_time': execution_time,
                'confidence': result.get('confidence', 0.5)
            }
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ AI –Ω–∞–≤–∏–≥–∞—Ü–∏–∏: {e}")
            return {
                'success': False,
                'error': str(e),
                'execution_time': time.time() - start_time
            }
    
    async def _analyze_current_state(self, page: Page) -> Dict[str, Any]:
        """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã"""
        try:
            logger.info("üì∏ –ü–æ–ª—É—á–∞—é —Å–∫—Ä–∏–Ω—à–æ—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—ã...")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
            try:
                page_url = page.url
                logger.info(f"üìç –¢–µ–∫—É—â–∏–π URL: {page_url}")
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–∫—Ä—ã—Ç–∞ –ª–∏ —Å—Ç—Ä–∞–Ω–∏—Ü–∞
                is_closed = page.is_closed()
                if is_closed:
                    logger.error("‚ùå –°—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞–∫—Ä—ã—Ç–∞, –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç")
                    return {'error': 'Page is closed'}
                    
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã: {e}")
                return {'error': f'Page state check failed: {str(e)}'}
            
            # –ü–æ–ª—É—á–∞–µ–º —Å–∫—Ä–∏–Ω—à–æ—Ç –∏ –±–∞–∑–æ–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é —Å —Ç–∞–π–º–∞—É—Ç–æ–º
            try:
                screenshot = await asyncio.wait_for(page.screenshot(), timeout=5.0)
                screenshot_b64 = base64.b64encode(screenshot).decode()
                logger.info(f"‚úÖ –°–∫—Ä–∏–Ω—à–æ—Ç –ø–æ–ª—É—á–µ–Ω: {len(screenshot_b64)} —Å–∏–º–≤–æ–ª–æ–≤")
            except asyncio.TimeoutError:
                logger.error("‚è∞ –¢–ê–ô–ú–ê–£–¢: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç –∑–∞ 5 —Å–µ–∫—É–Ω–¥")
                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Å–∫—Ä–∏–Ω—à–æ—Ç
                screenshot_b64 = ""
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∫—Ä–∏–Ω—à–æ—Ç–∞: {e}")
                screenshot_b64 = ""
            
            # –°–æ–±–∏—Ä–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å—Ç—Ä–∞–Ω–∏—Ü–µ
            logger.info("üìÑ –°–æ–±–∏—Ä–∞—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å—Ç—Ä–∞–Ω–∏—Ü–µ...")
            try:
                page_info = await asyncio.wait_for(page.evaluate("""
                () => {
                    return {
                        url: window.location.href,
                        title: document.title,
                        readyState: document.readyState,
                        visibleText: document.body?.innerText?.substring(0, 2000) || '',
                        forms: Array.from(document.forms).map(form => ({
                            action: form.action,
                            method: form.method,
                            elements: form.elements.length
                        })),
                        buttons: Array.from(document.querySelectorAll('button, input[type="submit"], input[type="button"]')).map(btn => ({
                            text: btn.textContent?.trim() || btn.value || '',
                            type: btn.type || btn.tagName,
                            visible: btn.offsetWidth > 0 && btn.offsetHeight > 0
                        })).filter(btn => btn.visible),
                        links: Array.from(document.querySelectorAll('a[href]')).map(link => ({
                            text: link.textContent?.trim() || '',
                            href: link.href,
                            visible: link.offsetWidth > 0 && link.offsetHeight > 0
                        })).filter(link => link.visible && link.text).slice(0, 20),
                        inputs: Array.from(document.querySelectorAll('input, select, textarea')).map(input => ({
                            type: input.type || input.tagName,
                            name: input.name || '',
                            placeholder: input.placeholder || '',
                            value: input.value || '',
                            visible: input.offsetWidth > 0 && input.offsetHeight > 0
                        })).filter(input => input.visible),
                        errors: Array.from(document.querySelectorAll('.error, .alert-danger, [class*="error"], [class*="warning"]')).map(el => el.textContent?.trim()).filter(text => text),
                        loading: document.querySelectorAll('.loading, .spinner, [class*="loading"], [class*="spinner"]').length > 0
                    }
                }
            """), timeout=5.0)
                logger.info("‚úÖ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å—Ç—Ä–∞–Ω–∏—Ü–µ –ø–æ–ª—É—á–µ–Ω–∞")
            except asyncio.TimeoutError:
                logger.error("‚è∞ –¢–ê–ô–ú–ê–£–¢: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å—Ç—Ä–∞–Ω–∏—Ü–µ –∑–∞ 5 —Å–µ–∫—É–Ω–¥")
                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –±–∞–∑–æ–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
                page_info = {
                    'url': 'unknown',
                    'title': 'unknown',
                    'readyState': 'unknown',
                    'buttons': [],
                    'links': [],
                    'forms': [],
                    'inputs': [],
                    'errors': [],
                    'loading': False,
                    'visibleText': ''
                }
            
            # –°–æ–∑–¥–∞–µ–º –ø—Ä–æ–º–ø—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è
            analysis_prompt = f"""
–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤–µ–±-—Å—Ç—Ä–∞–Ω–∏—Ü—ã –∏ –æ–ø—Ä–µ–¥–µ–ª–∏:

–ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –°–¢–†–ê–ù–ò–¶–ï:
URL: {page_info['url']}
–ó–∞–≥–æ–ª–æ–≤–æ–∫: {page_info['title']}
–°–æ—Å—Ç–æ—è–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏: {page_info['readyState']}

–≠–õ–ï–ú–ï–ù–¢–´ –ò–ù–¢–ï–†–§–ï–ô–°–ê:
–ö–Ω–æ–ø–∫–∏: {json.dumps(page_info['buttons'], ensure_ascii=False)}
–°—Å—ã–ª–∫–∏: {json.dumps(page_info['links'], ensure_ascii=False)}
–ü–æ–ª—è –≤–≤–æ–¥–∞: {json.dumps(page_info['inputs'], ensure_ascii=False)}
–§–æ—Ä–º—ã: {json.dumps(page_info['forms'], ensure_ascii=False)}

–û–®–ò–ë–ö–ò: {page_info['errors']}
–ó–ê–ì–†–£–ó–ö–ê: {page_info['loading']}

–í–ò–î–ò–ú–´–ô –¢–ï–ö–°–¢ (–ø–µ—Ä–≤—ã–µ 2000 —Å–∏–º–≤–æ–ª–æ–≤):
{page_info['visibleText']}

–ó–ê–î–ê–ß–ê: –û–ø—Ä–µ–¥–µ–ª–∏ —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∏ –≤–æ–∑–º–æ–∂–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è.

–û–¢–í–ï–¢–¨ –í –§–û–†–ú–ê–¢–ï JSON:
{{
    "page_type": "login_page|search_page|results_page|error_page|loading_page|unknown",
    "authentication_status": "logged_in|logged_out|2fa_required|session_expired|unknown",
    "available_actions": ["navigate_to_search", "fill_form", "click_button", "wait_for_load", etc.],
    "blocking_issues": ["captcha", "2fa_required", "session_expired", "page_not_loaded", etc.],
    "confidence": 0.95,
    "next_recommended_action": "–æ–ø–∏—Å–∞–Ω–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è",
    "context_clues": ["—Å–ø–∏—Å–æ–∫ –∫–ª—é—á–µ–≤—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–º–æ–≥–ª–∏ –≤ –∞–Ω–∞–ª–∏–∑–µ"]
}}
"""
            
            # –ü–æ–ª—É—á–∞–µ–º –∞–Ω–∞–ª–∏–∑ –æ—Ç AI
            try:
                logger.info("ü§ñ –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ Gemini AI...")
                logger.info(f"üìù –†–∞–∑–º–µ—Ä –ø—Ä–æ–º–ø—Ç–∞: {len(analysis_prompt)} —Å–∏–º–≤–æ–ª–æ–≤")
                ai_response = await self._get_ai_response(analysis_prompt, screenshot_b64)
                logger.info(f"üì® –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –æ—Ç AI: {len(ai_response) if ai_response else 0} —Å–∏–º–≤–æ–ª–æ–≤")
                ai_analysis = self._parse_json_response(ai_response)
                
                return {
                    'page_info': page_info,
                    'ai_analysis': ai_analysis,
                    'screenshot_b64': screenshot_b64,
                    'timestamp': time.time()
                }
                
            except Exception as ai_error:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–∞ –æ—Ç AI: {ai_error}")
                return {'error': f'AI response error: {str(ai_error)}'}
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è: {e}")
            return {'error': str(e)}
    
    async def _determine_strategy(self, analysis: Dict, goal: str, context: Dict = None) -> Dict[str, Any]:
        """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –¥–µ–π—Å—Ç–≤–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞–Ω–∞–ª–∏–∑–∞"""
        try:
            ai_analysis = analysis.get('ai_analysis', {})
            page_info = analysis.get('page_info', {})
            
            # –°–æ–∑–¥–∞–µ–º –ø—Ä–æ–º–ø—Ç –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
            strategy_prompt = f"""
–¢—ã - —ç–∫—Å–ø–µ—Ä—Ç –ø–æ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ –≤–µ–±-–Ω–∞–≤–∏–≥–∞—Ü–∏–∏. –û–ø—Ä–µ–¥–µ–ª–∏ –æ–ø—Ç–∏–º–∞–ª—å–Ω—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Ü–µ–ª–∏.

–¶–ï–õ–¨: {goal}

–¢–ï–ö–£–©–ï–ï –°–û–°–¢–û–Ø–ù–ò–ï:
{json.dumps(ai_analysis, indent=2, ensure_ascii=False)}

–î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ô –ö–û–ù–¢–ï–ö–°–¢:
{json.dumps(context or {}, indent=2, ensure_ascii=False)}

–ò–°–¢–û–†–ò–Ø –£–°–ü–ï–®–ù–´–• –î–ï–ô–°–¢–í–ò–ô:
{json.dumps(self.success_patterns.get(goal, []), indent=2, ensure_ascii=False)}

–ò–°–¢–û–†–ò–Ø –ù–ï–£–î–ê–ß–ù–´–• –î–ï–ô–°–¢–í–ò–ô:
{json.dumps(self.failure_patterns.get(goal, []), indent=2, ensure_ascii=False)}

–ó–ê–î–ê–ß–ê: –°–æ–∑–¥–∞–π –¥–µ—Ç–∞–ª—å–Ω—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º–∏ –¥–µ–π—Å—Ç–≤–∏—è–º–∏.

–û–¢–í–ï–¢–¨ –í –§–û–†–ú–ê–¢–ï JSON:
{{
    "strategy_type": "direct_navigation|form_filling|error_recovery|wait_and_retry|multi_step",
    "confidence": 0.9,
    "estimated_time": 15,
    "actions": [
        {{
            "step": 1,
            "action": "goto_url|click_element|fill_input|wait_for_element|take_screenshot",
            "target": "—Å–µ–ª–µ–∫—Ç–æ—Ä –∏–ª–∏ URL",
            "value": "–∑–Ω–∞—á–µ–Ω–∏–µ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ",
            "timeout": 10,
            "fallback_action": "—á—Ç–æ –¥–µ–ª–∞—Ç—å –µ—Å–ª–∏ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç",
            "success_indicator": "–∫–∞–∫ –ø–æ–Ω—è—Ç—å —á—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ",
            "description": "—á–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è"
        }}
    ],
    "fallback_strategy": "—á—Ç–æ –¥–µ–ª–∞—Ç—å –µ—Å–ª–∏ –æ—Å–Ω–æ–≤–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç",
    "risk_factors": ["—Å–ø–∏—Å–æ–∫ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º"],
    "success_probability": 0.85
}}
"""
            
            try:
                ai_response = await self._get_ai_response(strategy_prompt, analysis.get('screenshot_b64'))
                strategy = self._parse_json_response(ai_response)
                
                logger.info(f"üéØ AI –≤—ã–±—Ä–∞–ª —Å—Ç—Ä–∞—Ç–µ–≥–∏—é: {strategy.get('strategy_type')} (—É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {strategy.get('confidence', 0):.1%})")
                
                return strategy
                
            except Exception as ai_error:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –æ—Ç AI: {ai_error}")
                return {'strategy_type': 'error', 'actions': [], 'error': str(ai_error)}
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: {e}")
            return {'strategy_type': 'error', 'actions': [], 'error': str(e)}
    
    async def _execute_strategy(self, page: Page, strategy: Dict, goal: str) -> Dict[str, Any]:
        """–í—ã–ø–æ–ª–Ω—è–µ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –¥–µ–π—Å—Ç–≤–∏–π"""
        executed_actions = []
        success = True
        
        try:
            actions = strategy.get('actions', [])
            logger.info(f"üöÄ –í—ã–ø–æ–ª–Ω—è—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –∏–∑ {len(actions)} —à–∞–≥–æ–≤")
            
            for action in actions:
                step = action.get('step', 0)
                action_type = action.get('action')
                target = action.get('target')
                value = action.get('value')
                timeout = action.get('timeout', 3) * 1000  # –°–æ–∫—Ä–∞—â–µ–Ω —Ç–∞–π–º–∞—É—Ç —Å 10 –¥–æ 3 —Å–µ–∫—É–Ω–¥
                description = action.get('description', f"–®–∞–≥ {step}")
                
                logger.info(f"üéØ –®–∞–≥ {step}: {description}")
                
                try:
                    action_start = time.time()
                    action_result = await self._execute_single_action(page, action_type, target, value, timeout)
                    action_time = time.time() - action_start
                    
                    executed_actions.append({
                        'step': step,
                        'action': action_type,
                        'target': target,
                        'success': action_result,
                        'time': action_time,
                        'description': description
                    })
                    
                    if action_result:
                        logger.info(f"‚úÖ –®–∞–≥ {step} –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ ({action_time:.1f}—Å)")
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä —É—Å–ø–µ—Ö–∞ –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω
                        success_indicator = action.get('success_indicator')
                        if success_indicator:
                            await self._verify_action_success(page, success_indicator)
                    else:
                        logger.warning(f"‚ö†Ô∏è –®–∞–≥ {step} –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω")
                        
                        # –ü—Ä–æ–±—É–µ–º fallback –¥–µ–π—Å—Ç–≤–∏–µ
                        fallback = action.get('fallback_action')
                        if fallback:
                            logger.info(f"üîÑ –ü—Ä–æ–±—É—é fallback: {fallback}")
                            # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ fallback –¥–µ–π—Å—Ç–≤–∏—è
                        
                        success = False
                        break
                    
                    # –£–±—Ä–∞–Ω–∞ –∏–∑–±—ã—Ç–æ—á–Ω–∞—è –ø–∞—É–∑–∞ –º–µ–∂–¥—É –¥–µ–π—Å—Ç–≤–∏—è–º–∏
                    
                except Exception as e:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —à–∞–≥–∞ {step}: {e}")
                    executed_actions.append({
                        'step': step,
                        'action': action_type,
                        'success': False,
                        'error': str(e)
                    })
                    success = False
                    break
            
            return {
                'success': success,
                'actions': executed_actions,
                'confidence': strategy.get('confidence', 0.5) if success else 0.1
            }
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: {e}")
            return {
                'success': False,
                'actions': executed_actions,
                'error': str(e),
                'confidence': 0.1
            }
    
    async def _execute_single_action(self, page: Page, action_type: str, target: str, value: Any, timeout: int) -> bool:
        """–í—ã–ø–æ–ª–Ω—è–µ—Ç –æ–¥–Ω–æ –¥–µ–π—Å—Ç–≤–∏–µ"""
        try:
            if action_type == 'goto_url':
                await page.goto(target, wait_until='domcontentloaded', timeout=timeout)
                return True
                
            elif action_type == 'click_element':
                element = await page.wait_for_selector(target, timeout=timeout)
                if element:
                    await element.click()
                    return True
                    
            elif action_type == 'fill_input':
                element = await page.wait_for_selector(target, timeout=timeout)
                if element:
                    await element.clear()
                    await element.fill(str(value))
                    return True
                    
            elif action_type == 'select_option':
                element = await page.wait_for_selector(target, timeout=timeout)
                if element:
                    await element.select_option(label=str(value))
                    return True
                    
            elif action_type == 'wait_for_element':
                element = await page.wait_for_selector(target, timeout=timeout)
                return element is not None
                
            elif action_type == 'wait_for_load':
                await page.wait_for_load_state('domcontentloaded', timeout=timeout)
                return True
                
            elif action_type == 'take_screenshot':
                await page.screenshot(path=f"debug_screenshot_{int(time.time())}.png")
                return True
                
            return False
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –¥–µ–π—Å—Ç–≤–∏—è {action_type}: {e}")
            return False
    
    async def _verify_action_success(self, page: Page, success_indicator: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —É—Å–ø–µ—à–Ω–æ—Å—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –¥–µ–π—Å—Ç–≤–∏—è"""
        try:
            # –ú–æ–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å URL, –Ω–∞–ª–∏—á–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, —Ç–µ–∫—Å—Ç –∏ —Ç.–¥.
            if success_indicator.startswith('url_contains:'):
                expected_url_part = success_indicator.replace('url_contains:', '')
                current_url = page.url
                return expected_url_part in current_url
                
            elif success_indicator.startswith('element_exists:'):
                selector = success_indicator.replace('element_exists:', '')
                element = await page.query_selector(selector)
                return element is not None
                
            elif success_indicator.startswith('text_contains:'):
                expected_text = success_indicator.replace('text_contains:', '')
                page_text = await page.text_content('body')
                return expected_text in page_text
                
            return True
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—Å–ø–µ—Ö–∞: {e}")
            return False
    
    async def _learn_from_result(self, analysis: Dict, strategy: Dict, result: Dict, goal: str):
        """–û–±—É—á–∞–µ—Ç—Å—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è"""
        try:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –∏—Å—Ç–æ—Ä–∏—é
            learning_entry = {
                'timestamp': time.time(),
                'goal': goal,
                'page_type': analysis.get('ai_analysis', {}).get('page_type'),
                'strategy_type': strategy.get('strategy_type'),
                'success': result.get('success', False),
                'confidence': result.get('confidence', 0),
                'actions': result.get('actions', [])
            }
            
            self.action_history.append(learning_entry)
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω—ã —É—Å–ø–µ—Ö–∞/–Ω–µ—É–¥–∞—á
            if result.get('success'):
                if goal not in self.success_patterns:
                    self.success_patterns[goal] = []
                self.success_patterns[goal].append({
                    'strategy': strategy,
                    'context': analysis.get('ai_analysis', {}),
                    'confidence': result.get('confidence', 0)
                })
                # –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —É—Å–ø–µ—à–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
                self.success_patterns[goal] = self.success_patterns[goal][-10:]
            else:
                if goal not in self.failure_patterns:
                    self.failure_patterns[goal] = []
                self.failure_patterns[goal].append({
                    'strategy': strategy,
                    'context': analysis.get('ai_analysis', {}),
                    'error': result.get('error')
                })
                self.failure_patterns[goal] = self.failure_patterns[goal][-10:]
            
            logger.info(f"üìö AI –æ–±–Ω–æ–≤–∏–ª –±–∞–∑—É –∑–Ω–∞–Ω–∏–π –¥–ª—è —Ü–µ–ª–∏ '{goal}'")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—É—á–µ–Ω–∏—è: {e}")
    
    async def _get_ai_response(self, prompt: str, screenshot_b64: str = None) -> str:
        """–ü–æ–ª—É—á–∞–µ—Ç –æ—Ç–≤–µ—Ç –æ—Ç AI —Å —Ç–∞–π–º–∞—É—Ç–æ–º"""
        try:
            content = [prompt]
            
            if screenshot_b64:
                content.append({
                    'mime_type': 'image/png',
                    'data': screenshot_b64
                })
            
            # –î–æ–±–∞–≤–ª—è–µ–º —Ç–∞–π–º–∞—É—Ç 30 —Å–µ–∫—É–Ω–¥ –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ –∫ AI
            logger.info("ü§ñ –û—Ç–ø—Ä–∞–≤–ª—è—é –∑–∞–ø—Ä–æ—Å –∫ Gemini AI...")
            start_time = time.time()
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º asyncio.wait_for –¥–ª—è —Ç–∞–π–º–∞—É—Ç–∞
            import asyncio
            
            # –°–æ–∑–¥–∞–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—É—é –æ–±–µ—Ä—Ç–∫—É –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞
            async def generate_content_async():
                return await asyncio.get_event_loop().run_in_executor(
                    None, 
                    self.model.generate_content,
                    content
                )
            
            try:
                response = await asyncio.wait_for(generate_content_async(), timeout=15.0)
                elapsed = time.time() - start_time
                logger.info(f"‚úÖ –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –æ—Ç AI –∑–∞ {elapsed:.1f}—Å")
                return response.text
                
            except asyncio.TimeoutError:
                elapsed = time.time() - start_time
                logger.error(f"‚è∞ –¢–ê–ô–ú–ê–£–¢: AI –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª –∑–∞ {elapsed:.1f}—Å")
                raise Exception("AI request timeout after 15 seconds")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ AI: {e}")
            raise  # –ü—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –æ—à–∏–±–∫—É –¥–∞–ª—å—à–µ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
    
    def _parse_json_response(self, response: str) -> Dict[str, Any]:
        """–ü–∞—Ä—Å–∏—Ç JSON –æ—Ç–≤–µ—Ç –æ—Ç AI"""
        try:
            # –ò—â–µ–º JSON –≤ –æ—Ç–≤–µ—Ç–µ
            json_start = response.find('{')
            json_end = response.rfind('}') + 1
            
            if json_start != -1 and json_end != -1:
                json_str = response[json_start:json_end]
                return json.loads(json_str)
            
            logger.warning("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ JSON –≤ –æ—Ç–≤–µ—Ç–µ AI")
            return {}
            
        except json.JSONDecodeError as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON: {e}")
            return {}
    
    def get_learning_stats(self) -> Dict[str, Any]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –æ–±—É—á–µ–Ω–∏—è"""
        total_actions = len(self.action_history)
        successful_actions = sum(1 for action in self.action_history if action['success'])
        
        return {
            'total_actions': total_actions,
            'successful_actions': successful_actions,
            'success_rate': successful_actions / total_actions if total_actions > 0 else 0,
            'learned_goals': list(self.success_patterns.keys()),
            'success_patterns_count': sum(len(patterns) for patterns in self.success_patterns.values()),
            'failure_patterns_count': sum(len(patterns) for patterns in self.failure_patterns.values())
        }